# Release workflow - builds and publishes fresh-editor for all platforms
# Replaces cargo-dist with direct cargo builds

name: Release
permissions:
  contents: write
  id-token: write

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'

env:
  CARGO_TERM_COLOR: always

jobs:
  # Extract version and determine if we're publishing
  plan:
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      publishing: ${{ steps.version.outputs.publishing }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    steps:
      - uses: actions/checkout@v6
      - name: Extract version info
        id: version
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, get version from Cargo.toml
            VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
            TAG=""
            PUBLISHING="false"
          else
            # For tags, extract from ref
            TAG="${{ github.ref_name }}"
            VERSION="${TAG#v}"
            PUBLISHING="true"
          fi

          # Check if prerelease (contains -, like 0.1.0-beta.1)
          if [[ "$VERSION" == *-* ]]; then
            IS_PRERELEASE="true"
          else
            IS_PRERELEASE="false"
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "publishing=$PUBLISHING" >> "$GITHUB_OUTPUT"
          echo "is_prerelease=$IS_PRERELEASE" >> "$GITHUB_OUTPUT"

          echo "Version: $VERSION"
          echo "Tag: $TAG"
          echo "Publishing: $PUBLISHING"
          echo "Is prerelease: $IS_PRERELEASE"

  # Test Nix build
  test-nix-build:
    needs: plan
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Build with Nix
        run: |
          echo "=== Building fresh with nix build ==="
          nix build .#fresh --print-build-logs

          echo ""
          echo "=== Verifying binary ==="
          ./result/bin/fresh --version

          echo ""
          echo "=== Nix build test PASSED ==="

  # Build binaries for each platform
  build:
    needs: plan
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-22.04
            archive_ext: tar.xz
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-22.04
            archive_ext: tar.xz
            cross: true
          - target: x86_64-apple-darwin
            os: macos-15
            archive_ext: tar.xz
          - target: aarch64-apple-darwin
            os: macos-latest
            archive_ext: tar.xz
          - target: x86_64-pc-windows-msvc
            os: windows-2022
            archive_ext: zip
    runs-on: ${{ matrix.os }}
    env:
      VERSION: ${{ needs.plan.outputs.version }}
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (Linux ARM)
        if: matrix.cross && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Build release binary
        shell: bash
        run: |
          if [ "${{ matrix.cross }}" = "true" ] && [ "${{ matrix.target }}" = "aarch64-unknown-linux-gnu" ]; then
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
          fi
          cargo build --release --target ${{ matrix.target }}

      - name: Create archive (Unix)
        if: runner.os != 'Windows'
        run: |
          ARCHIVE_NAME="fresh-editor-${{ matrix.target }}"
          mkdir -p "${ARCHIVE_NAME}"
          cp target/${{ matrix.target }}/release/fresh "${ARCHIVE_NAME}/"
          cp README.md LICENSE CHANGELOG.md "${ARCHIVE_NAME}/" 2>/dev/null || true
          cp -r plugins "${ARCHIVE_NAME}/" 2>/dev/null || true

          if [ "${{ matrix.archive_ext }}" = "tar.xz" ]; then
            tar -cJvf "${ARCHIVE_NAME}.tar.xz" "${ARCHIVE_NAME}"
            sha256sum "${ARCHIVE_NAME}.tar.xz" > "${ARCHIVE_NAME}.tar.xz.sha256"
          else
            tar -czvf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
            sha256sum "${ARCHIVE_NAME}.tar.gz" > "${ARCHIVE_NAME}.tar.gz.sha256"
          fi

      - name: Create archive (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ARCHIVE_NAME = "fresh-editor-${{ matrix.target }}"
          New-Item -ItemType Directory -Path $ARCHIVE_NAME -Force
          Copy-Item "target/${{ matrix.target }}/release/fresh.exe" "$ARCHIVE_NAME/"
          Copy-Item "README.md", "LICENSE", "CHANGELOG.md" "$ARCHIVE_NAME/" -ErrorAction SilentlyContinue
          Copy-Item -Recurse "plugins" "$ARCHIVE_NAME/" -ErrorAction SilentlyContinue

          Compress-Archive -Path "$ARCHIVE_NAME/*" -DestinationPath "$ARCHIVE_NAME.zip"
          $hash = (Get-FileHash "$ARCHIVE_NAME.zip" -Algorithm SHA256).Hash.ToLower()
          "$hash  $ARCHIVE_NAME.zip" | Out-File -Encoding ASCII "$ARCHIVE_NAME.zip.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: artifacts-${{ matrix.target }}
          path: |
            fresh-editor-${{ matrix.target }}.${{ matrix.archive_ext }}
            fresh-editor-${{ matrix.target }}.${{ matrix.archive_ext }}.sha256

  # Build musl static binaries (no plugins)
  build-musl:
    needs: plan
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    uses: ./.github/workflows/musl-builds.yml
    secrets: inherit

  # Build Linux packages (.deb, .rpm)
  build-linux-packages:
    needs: [plan, build]
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    uses: ./.github/workflows/linux-packages.yml
    secrets: inherit

  # Build Flatpak bundle
  build-flatpak:
    needs: [plan, build]
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    uses: ./.github/workflows/flatpak-build.yml
    with:
      version: ${{ needs.plan.outputs.version }}
    secrets: inherit

  # Build AppImage
  build-appimage:
    needs: [plan, build]
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    uses: ./.github/workflows/appimage-build.yml
    with:
      version: ${{ needs.plan.outputs.version }}
    secrets: inherit

  # Build npm package
  build-npm-package:
    needs: [plan, build]
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    runs-on: ubuntu-22.04
    env:
      VERSION: ${{ needs.plan.outputs.version }}
    steps:
      - uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24.x'

      - name: Download all build artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: artifacts-*
          path: artifacts/
          merge-multiple: true

      - name: List downloaded artifacts
        run: ls -la artifacts/

      - name: Create npm package
        run: |
          mkdir -p npm-package

          # Create package.json
          cat > npm-package/package.json << 'PKGJSON'
          {
            "name": "@fresh-editor/fresh-editor",
            "version": "${{ needs.plan.outputs.version }}",
            "description": "A modern terminal-based text editor with plugin support",
            "repository": {
              "type": "git",
              "url": "https://github.com/sinelaw/fresh.git"
            },
            "license": "Apache-2.0",
            "bin": {
              "fresh": "run-fresh.js"
            },
            "scripts": {
              "postinstall": "node install.js"
            },
            "files": [
              "binary.js",
              "binary-install.js",
              "install.js",
              "run-fresh.js",
              "plugins/**/*",
              "README.md",
              "LICENSE",
              "CHANGELOG.md"
            ],
            "os": ["darwin", "linux", "win32"],
            "cpu": ["x64", "arm64"],
            "keywords": ["editor", "terminal", "cli", "text-editor", "vim"],
            "engines": {
              "node": ">=18"
            }
          }
          PKGJSON

          # Fix version in package.json
          sed -i "s/\${{ needs.plan.outputs.version }}/${VERSION}/g" npm-package/package.json

          # Create binary.js - platform detection and download
          cat > npm-package/binary.js << 'BINARYJS'
          const os = require('os');
          const path = require('path');

          function getBinaryInfo() {
            const platform = os.platform();
            const arch = os.arch();

            const targets = {
              'darwin-x64': { target: 'x86_64-apple-darwin', ext: 'tar.xz' },
              'darwin-arm64': { target: 'aarch64-apple-darwin', ext: 'tar.xz' },
              'linux-x64': { target: 'x86_64-unknown-linux-gnu', ext: 'tar.xz' },
              'linux-arm64': { target: 'aarch64-unknown-linux-gnu', ext: 'tar.xz' },
              'win32-x64': { target: 'x86_64-pc-windows-msvc', ext: 'zip' }
            };

            const key = `${platform}-${arch}`;
            const info = targets[key];

            if (!info) {
              throw new Error(`Unsupported platform: ${platform}-${arch}`);
            }

            return {
              ...info,
              binaryName: platform === 'win32' ? 'fresh.exe' : 'fresh'
            };
          }

          module.exports = { getBinaryInfo };
          BINARYJS

          # Create binary-install.js - download and extract logic
          cat > npm-package/binary-install.js << 'INSTALLJS'
          const https = require('https');
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          const { getBinaryInfo } = require('./binary');

          const VERSION = require('./package.json').version;
          const REPO = 'sinelaw/fresh';

          function download(url, dest) {
            return new Promise((resolve, reject) => {
              const file = fs.createWriteStream(dest);
              https.get(url, (response) => {
                if (response.statusCode === 302 || response.statusCode === 301) {
                  download(response.headers.location, dest).then(resolve).catch(reject);
                  return;
                }
                if (response.statusCode !== 200) {
                  reject(new Error(`Failed to download: ${response.statusCode}`));
                  return;
                }
                response.pipe(file);
                file.on('finish', () => { file.close(); resolve(); });
              }).on('error', reject);
            });
          }

          async function install() {
            const info = getBinaryInfo();
            const archiveName = `fresh-editor-${info.target}.${info.ext}`;
            const url = `https://github.com/${REPO}/releases/download/v${VERSION}/${archiveName}`;
            const archivePath = path.join(__dirname, archiveName);
            const binDir = path.join(__dirname, 'bin');

            console.log(`Downloading ${url}...`);
            await download(url, archivePath);

            fs.mkdirSync(binDir, { recursive: true });

            if (info.ext === 'tar.xz') {
              execSync(`tar -xJf "${archivePath}" -C "${binDir}" --strip-components=1`, { stdio: 'inherit' });
            } else if (info.ext === 'zip') {
              if (process.platform === 'win32') {
                execSync(`powershell -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${binDir}' -Force"`, { stdio: 'inherit' });
                // Move files from nested directory
                const nested = path.join(binDir, `fresh-editor-${info.target}`);
                if (fs.existsSync(nested)) {
                  fs.readdirSync(nested).forEach(f => {
                    fs.renameSync(path.join(nested, f), path.join(binDir, f));
                  });
                  fs.rmdirSync(nested);
                }
              } else {
                execSync(`unzip -o "${archivePath}" -d "${binDir}"`, { stdio: 'inherit' });
              }
            }

            fs.unlinkSync(archivePath);
            console.log('fresh-editor installed successfully!');
          }

          module.exports = { install };
          INSTALLJS

          # Create install.js
          cat > npm-package/install.js << 'POSTINSTALL'
          const { install } = require('./binary-install');
          install().catch(err => { console.error(err); process.exit(1); });
          POSTINSTALL

          # Create run-fresh.js
          cat > npm-package/run-fresh.js << 'RUNJS'
          #!/usr/bin/env node
          const { spawn } = require('child_process');
          const path = require('path');
          const { getBinaryInfo } = require('./binary');

          const info = getBinaryInfo();
          const binPath = path.join(__dirname, 'bin', info.binaryName);

          const child = spawn(binPath, process.argv.slice(2), { stdio: 'inherit' });
          child.on('exit', (code) => process.exit(code || 0));
          RUNJS

          # Copy supporting files
          cp README.md LICENSE CHANGELOG.md npm-package/ 2>/dev/null || true
          cp -r plugins npm-package/ 2>/dev/null || true

          # Create the tarball
          cd npm-package
          npm pack
          mv *.tgz ../fresh-editor-npm-package.tar.gz
          cd ..

      - name: Upload npm package artifact
        uses: actions/upload-artifact@v6
        with:
          name: artifacts-npm-package
          path: fresh-editor-npm-package.tar.gz

  # Build Homebrew formula
  build-homebrew-formula:
    needs: [plan, build]
    if: ${{ needs.plan.outputs.publishing == 'true' }}
    runs-on: ubuntu-22.04
    env:
      VERSION: ${{ needs.plan.outputs.version }}
    steps:
      - uses: actions/checkout@v6

      - name: Download artifacts for checksums
        uses: actions/download-artifact@v7
        with:
          pattern: artifacts-*
          path: artifacts/
          merge-multiple: true

      - name: Generate Homebrew formula
        run: |
          # Read checksums
          X86_DARWIN_SHA=$(cat artifacts/fresh-editor-x86_64-apple-darwin.tar.xz.sha256 | awk '{print $1}')
          ARM_DARWIN_SHA=$(cat artifacts/fresh-editor-aarch64-apple-darwin.tar.xz.sha256 | awk '{print $1}')
          X86_LINUX_SHA=$(cat artifacts/fresh-editor-x86_64-unknown-linux-gnu.tar.xz.sha256 | awk '{print $1}')
          ARM_LINUX_SHA=$(cat artifacts/fresh-editor-aarch64-unknown-linux-gnu.tar.xz.sha256 | awk '{print $1}')

          cat > fresh.rb << FORMULA
          class Fresh < Formula
            desc "A modern terminal-based text editor with plugin support"
            homepage "https://github.com/sinelaw/fresh"
            version "${VERSION}"
            license "Apache-2.0"

            on_macos do
              on_intel do
                url "https://github.com/sinelaw/fresh/releases/download/v${VERSION}/fresh-editor-x86_64-apple-darwin.tar.xz"
                sha256 "${X86_DARWIN_SHA}"
              end
              on_arm do
                url "https://github.com/sinelaw/fresh/releases/download/v${VERSION}/fresh-editor-aarch64-apple-darwin.tar.xz"
                sha256 "${ARM_DARWIN_SHA}"
              end
            end

            on_linux do
              on_intel do
                url "https://github.com/sinelaw/fresh/releases/download/v${VERSION}/fresh-editor-x86_64-unknown-linux-gnu.tar.xz"
                sha256 "${X86_LINUX_SHA}"
              end
              on_arm do
                url "https://github.com/sinelaw/fresh/releases/download/v${VERSION}/fresh-editor-aarch64-unknown-linux-gnu.tar.xz"
                sha256 "${ARM_LINUX_SHA}"
              end
            end

            def install
              bin.install "fresh"
              share.install "plugins" if File.directory?("plugins")
            end

            test do
              system "#{bin}/fresh", "--version"
            end
          end
          FORMULA

          cat fresh.rb

      - name: Upload Homebrew formula
        uses: actions/upload-artifact@v6
        with:
          name: artifacts-homebrew-formula
          path: fresh.rb

  # Create GitHub Release
  # Only runs if ALL needed jobs succeed - uses !cancelled() to run after all jobs complete,
  # then !failure() ensures none failed
  release:
    needs: [plan, build, build-musl, build-linux-packages, build-flatpak, build-appimage, build-npm-package, build-homebrew-formula, test-nix-build]
    if: ${{ !cancelled() && !failure() && needs.plan.outputs.publishing == 'true' }}
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VERSION: ${{ needs.plan.outputs.version }}
      TAG: ${{ needs.plan.outputs.tag }}
    steps:
      - uses: actions/checkout@v6

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: artifacts-*
          path: artifacts/
          merge-multiple: true

      - name: List artifacts
        run: ls -la artifacts/

      - name: Extract changelog for this version
        id: changelog
        run: |
          # Extract the changelog section for this version
          # CHANGELOG format: ## 0.1.53 (no brackets), sections end with ---
          VERSION="${{ needs.plan.outputs.version }}"
          awk -v ver="$VERSION" '
            /^## [0-9]/ {
              if (found) exit
              if ($2 == ver) found=1
            }
            /^---$/ { if (found) exit }
            found { print }
          ' CHANGELOG.md > release_notes.md || echo "Release ${VERSION}" > release_notes.md

          # If empty, use a default message
          if [ ! -s release_notes.md ]; then
            echo "Release ${VERSION}" > release_notes.md
          fi

          cat release_notes.md

      - name: Create GitHub Release
        run: |
          PRERELEASE_FLAG=""
          if [ "${{ needs.plan.outputs.is_prerelease }}" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          gh release create "$TAG" \
            --target "${{ github.sha }}" \
            $PRERELEASE_FLAG \
            --title "fresh-editor ${VERSION}" \
            --notes-file release_notes.md \
            artifacts/*.tar.xz \
            artifacts/*.tar.xz.sha256 \
            artifacts/*.tar.gz \
            artifacts/*.tar.gz.sha256 \
            artifacts/*.zip \
            artifacts/*.zip.sha256 \
            artifacts/*.deb \
            artifacts/*.rpm \
            artifacts/*.flatpak \
            artifacts/*.flatpak.sha256 \
            artifacts/*.AppImage \
            artifacts/*.AppImage.sha256 \
            artifacts/fresh.rb \
            2>/dev/null || true

  # Publish to Homebrew tap
  publish-homebrew:
    needs: [plan, release]
    if: ${{ needs.plan.outputs.publishing == 'true' && needs.plan.outputs.is_prerelease != 'true' }}
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VERSION: ${{ needs.plan.outputs.version }}
    steps:
      - name: Download Homebrew formula
        uses: actions/download-artifact@v7
        with:
          name: artifacts-homebrew-formula
          path: formula/

      - uses: actions/checkout@v6
        with:
          repository: sinelaw/homebrew-fresh
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          path: tap

      - name: Update Homebrew tap
        run: |
          cp formula/fresh.rb tap/Formula/fresh.rb
          cd tap
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add Formula/fresh.rb
          git commit -m "fresh ${VERSION}" || echo "No changes to commit"
          git push

  # Publish to npm
  publish-npm:
    needs: [plan, release]
    if: ${{ needs.plan.outputs.publishing == 'true' && needs.plan.outputs.is_prerelease != 'true' }}
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ needs.plan.outputs.version }}" ]; then
            VERSION="${{ needs.plan.outputs.version }}"
          else
            VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Publishing npm package for version: $VERSION"

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'

      - name: Update npm
        run: npm install -g npm@latest

      - name: Create npm package
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          mkdir -p npm-package

          # Create package.json
          cat > npm-package/package.json << PKGJSON
          {
            "name": "@fresh-editor/fresh-editor",
            "version": "${VERSION}",
            "description": "A modern terminal-based text editor with plugin support",
            "repository": {
              "type": "git",
              "url": "https://github.com/sinelaw/fresh.git"
            },
            "license": "Apache-2.0",
            "bin": {
              "fresh": "run-fresh.js"
            },
            "scripts": {
              "postinstall": "node install.js"
            },
            "files": [
              "binary.js",
              "binary-install.js",
              "install.js",
              "run-fresh.js",
              "plugins/**/*",
              "README.md",
              "LICENSE",
              "CHANGELOG.md"
            ],
            "os": ["darwin", "linux", "win32"],
            "cpu": ["x64", "arm64"],
            "keywords": ["editor", "terminal", "cli", "text-editor", "vim"],
            "engines": {
              "node": ">=18"
            }
          }
          PKGJSON

          # Create binary.js - platform detection and download
          cat > npm-package/binary.js << 'BINARYJS'
          const os = require('os');
          const path = require('path');

          function getBinaryInfo() {
            const platform = os.platform();
            const arch = os.arch();

            const targets = {
              'darwin-x64': { target: 'x86_64-apple-darwin', ext: 'tar.xz' },
              'darwin-arm64': { target: 'aarch64-apple-darwin', ext: 'tar.xz' },
              'linux-x64': { target: 'x86_64-unknown-linux-gnu', ext: 'tar.xz' },
              'linux-arm64': { target: 'aarch64-unknown-linux-gnu', ext: 'tar.xz' },
              'win32-x64': { target: 'x86_64-pc-windows-msvc', ext: 'zip' }
            };

            const key = `${platform}-${arch}`;
            const info = targets[key];

            if (!info) {
              throw new Error(`Unsupported platform: ${platform}-${arch}`);
            }

            return {
              ...info,
              binaryName: platform === 'win32' ? 'fresh.exe' : 'fresh'
            };
          }

          module.exports = { getBinaryInfo };
          BINARYJS

          # Create binary-install.js - download and extract logic
          cat > npm-package/binary-install.js << 'INSTALLJS'
          const https = require('https');
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          const { getBinaryInfo } = require('./binary');

          const VERSION = require('./package.json').version;
          const REPO = 'sinelaw/fresh';

          function download(url, dest) {
            return new Promise((resolve, reject) => {
              const file = fs.createWriteStream(dest);
              https.get(url, (response) => {
                if (response.statusCode === 302 || response.statusCode === 301) {
                  download(response.headers.location, dest).then(resolve).catch(reject);
                  return;
                }
                if (response.statusCode !== 200) {
                  reject(new Error(`Failed to download: ${response.statusCode}`));
                  return;
                }
                response.pipe(file);
                file.on('finish', () => { file.close(); resolve(); });
              }).on('error', reject);
            });
          }

          async function install() {
            const info = getBinaryInfo();
            const archiveName = `fresh-editor-${info.target}.${info.ext}`;
            const url = `https://github.com/${REPO}/releases/download/v${VERSION}/${archiveName}`;
            const archivePath = path.join(__dirname, archiveName);
            const binDir = path.join(__dirname, 'bin');

            console.log(`Downloading ${url}...`);
            await download(url, archivePath);

            fs.mkdirSync(binDir, { recursive: true });

            if (info.ext === 'tar.xz') {
              execSync(`tar -xJf "${archivePath}" -C "${binDir}" --strip-components=1`, { stdio: 'inherit' });
            } else if (info.ext === 'zip') {
              if (process.platform === 'win32') {
                execSync(`powershell -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${binDir}' -Force"`, { stdio: 'inherit' });
                // Move files from nested directory
                const nested = path.join(binDir, `fresh-editor-${info.target}`);
                if (fs.existsSync(nested)) {
                  fs.readdirSync(nested).forEach(f => {
                    fs.renameSync(path.join(nested, f), path.join(binDir, f));
                  });
                  fs.rmdirSync(nested);
                }
              } else {
                execSync(`unzip -o "${archivePath}" -d "${binDir}"`, { stdio: 'inherit' });
              }
            }

            fs.unlinkSync(archivePath);
            console.log('fresh-editor installed successfully!');
          }

          module.exports = { install };
          INSTALLJS

          # Create install.js
          cat > npm-package/install.js << 'POSTINSTALL'
          const { install } = require('./binary-install');
          install().catch(err => { console.error(err); process.exit(1); });
          POSTINSTALL

          # Create run-fresh.js
          cat > npm-package/run-fresh.js << 'RUNJS'
          #!/usr/bin/env node
          const { spawn } = require('child_process');
          const path = require('path');
          const { getBinaryInfo } = require('./binary');

          const info = getBinaryInfo();
          const binPath = path.join(__dirname, 'bin', info.binaryName);

          const child = spawn(binPath, process.argv.slice(2), { stdio: 'inherit' });
          child.on('exit', (code) => process.exit(code || 0));
          RUNJS

          # Copy supporting files
          cp README.md LICENSE CHANGELOG.md npm-package/ 2>/dev/null || true
          cp -r plugins npm-package/ 2>/dev/null || true

          # Create the tarball
          cd npm-package
          npm pack
          mv *.tgz ../fresh-editor-npm-package.tar.gz
          cd ..

          echo "Created npm package:"
          ls -la fresh-editor-npm-package.tar.gz

      - name: Publish to npm with provenance (OIDC)
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Publishing npm package for version ${VERSION}"
          npm publish --access public --provenance ./fresh-editor-npm-package.tar.gz

  # Publish to AUR
  publish-aur:
    needs: [plan, release]
    if: ${{ needs.plan.outputs.publishing == 'true' && needs.plan.outputs.is_prerelease != 'true' }}
    uses: ./.github/workflows/aur-publish.yml
    with:
      version: ${{ needs.plan.outputs.version }}
    secrets: inherit

  # Publish to crates.io
  publish-cargo:
    needs: [plan, release]
    if: ${{ needs.plan.outputs.publishing == 'true' && needs.plan.outputs.is_prerelease != 'true' }}
    uses: ./.github/workflows/cargo-publish.yml
    secrets: inherit
